

/** Copy constructor syntax **/
	const className &ref


+ Why we don't use pointers in copy constructor ?

	+ Since the copy constructor is generated by the compiler when not specified by the user,
	  it make sense to use the same signature for user-defined 
	  copy constructor that is used for compiler-defined copy constructor.
	  If someone define a constructor that take a pointer instead of a reference, 
	  then if the caller forget to take the address of the object from which the new object is to be created,
	  then instead of using user-constructor with a pointer, 
	  the compiler generated copy constructor (with a reference) would be used.

	+ reference acts like a const pointer that is implicitly dereferenced.
	  Because references always “point” to valid objects, and can never be pointed to deallocated memory, 
	  references are safer to use than pointers. Thus the reference should generally be preferred. 
	  Pointers should generally only be used in situations where references are not sufficient .
	  So, to prevent memory corruption issues References are preferred to pointers.
	  
	+ First, Const references are often used as function parameters because const references
   	  allow us to access but not change the value of an object, 
	  they can be used to give a function access to an object, 
	  but give assurance to caller that the object will not be changed at all by the function.
	
